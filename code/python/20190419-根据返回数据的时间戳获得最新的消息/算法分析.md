# 根据返回数据的时间戳获得最新的消息

### 场景分析

某一轮询执行的函数，根据返回的JSON数据中消息的时间戳判断获得的最新消息，并输出出来。但是已经输出过的消息不再输出。

### 算法分析

#### 最简模型

定义`order_time`为返回数据的时间戳；`last_order_time`为全局变量，用于存储已输出消息的时间戳；`getCurrentTime()`方法可返回当前的系统时间戳。

那么最简单的情况便是判断`order_time`是否落在`last_order_time`与`current_time`（如果服务器时间一致一般不会出现大于`current_time`的情况）之间的开区间内，若是，则更新`last_order_time`为当前`order_time`；若不是，则继续。

这样的算法会存在一个问题，即首次运行时`last_order_time`怎么赋值。若赋值为`current_time`，则不等式不成立。因此`last_order_time`初始值必须小于`current_time`，需要进入修正值。

#### 可回溯消息模型

源码： [get_last_msg_with_back_to.py](get_last_msg_with_back_to.py) 

```python
FIX_SECTION = 5						# 定义修正值，使初始的last_order_time小于current_time某一个值
last_order_time = getCurrentTime() - FIX_SECTION

def getLastMsg(response, back_to):
    msg = []						# 返回值list
    global last_order_time			# 调用全局变量
    last_order_time -= back_to		# 时间回溯，回溯时长要看修正值、back_to以及该函数具体调用的时间
    current_time = getCurrentTime()	# 当前时间
    # 对传入数据按时间戳降序排序，避免后续更新last_order_time时出错
    response = sorted(response, key = lambda e: e.__getitem__('timestamp'), reverse = True)
    # 遍历传入数据
    for res in response:
        # 判断order_time是否大于current_time，若大于则将值束缚为current_time
        if res['timestamp'] > current_time:
            res['timestamp'] == current_time
        # 判断order_time是否大于last_order_time，若大于则说明是最新消息，追加到msg中，并更新last_order_time
        if res['timestamp'] > last_order_time:
            msg.append(res['content'])
            last_order_time = res['timestamp']
    # 返回msg
    return msg
```

